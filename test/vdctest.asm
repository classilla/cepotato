// vim: set syntax=off:

/*

   small VDC demo of low-resolution 320x200 mode on the Commodore 128
   displays bitmap on both VIC and VDC screens
   *** runs in 64 mode ***

   (c)2023 Cameron Kaiser. all rights reserved. BSD license.
   https://oldvcr.blogspot.com/

*/

zp	= 253

	.word $0801
	*=$0801

; basic loader

	.word $080b
	.word $fce2
	.byte $9e, $32, $30, $36, $31
	.byte $00, $00, $00

	jmp entry

	.asc $0d, $0a, "http://oldvcr.blogspot.com/", $0d, $0a

	; vdc initialization bytes (NTSC)
vdcri	.byt $7e,$50,$66,$49,$20,$e0,$19,$1d
	/* PAL:              ^^^- $27    ^^^- $20 */
	.byt $fc,$e7,$e0,$f0,$00,$00,$20,$00
	.byt $ff,$ff,$00,$00,$08,$00,$78,$e8
	.byt $20,$ff,$f0,$00,$2f,$e7,$ff,$ff
	.byt $ff,$ff,$7d,$64,$f5

	; workspace for the all important register 25
vdc25	.byt 0

	; generic read or write to a VDC register
vdcrm	ldx #$1f	; enter here for memory
vdcrw	stx $d600	; enter here for other registers in X
	bit $d600
	bpl *-3		; wait for ready
vdcop	sta $d601	; change opcode to $ad=read $8d=store
	rts

entry
	; display regular hi-res at $2000
	; generated by print shop screen magic
	lda #0
	sta 53280
	sta 53281
	lda #11
	sta 53265
	lda #16
	ldx #0
cloop	sta $0400,x
	sta $0500,x
	sta $0600,x
	sta $0700,x
	inx
	bne cloop
	lda #31
	sta 53272
	lda #59
	sta 53265

	; default initialize vdc
	lda #$8d
	sta vdcop
	ldy #$47	; handle version 0 VDC (early 128s)
	lda $d600
	and #$03
	bne *+4
	ldy #$40	; old vdc use value 40, new vdc use value 47
	tya
	ldx #25
	sta vdc25
	jsr vdcrw

	; load default NTSC values, skipping $ffs
	ldx #0
vloop	lda vdcri,x
	cmp #$ff
	beq *+5
	jsr vdcrw
	inx
	cpx #37
	bcc vloop

	; 8568 has an extra register 37 for hsync/vsync (ignored on 8563)
	; set both hsync (7) and vsync (6) bits for positive polarity
	; since most people will use a Commodore 1902 monitor or similar
	lda #255
	jsr vdcrw

	; patch for PAL
	lda 678
	beq vnotpal
	ldx #4
	lda #$27
	jsr vdcrw
	ldx #7
	lda #$20
	jsr vdcrw
vnotpal

	; force VDC 320x200 mode
	; do this in this weird order since it works on both
	; VICE and a real NTSC 128DCR
	ldx #25
	lda vdc25
	ora #128
	jsr vdcrw		; hires on

	ldx #0
	lda #63
	jsr vdcrw		; 64 clock cycles per rasterline

	ldx #1
	lda #40
	jsr vdcrw		; 40 visible character columns displayed

	ldx #25
	lda vdc25
	ora #144
	and #191
	jsr vdcrw		; hires + double pixel clock both on,
				; attributes off

	ldx #22
	lda #$89
	jsr vdcrw		; character width to 9

	ldx #27
	lda #1
	jsr vdcrw		; insert "wait byte" between rows to remove
				; dot noise on right edge

	ldx #2			
	lda #53
	jsr vdcrw		; hsync pos to 53, was best on tested screens

	; copy VIC 320x200 screen to VDC memory
	; attempt to do as much as we can with VDC autoincrement

	ldx #18
	lda #0
	jsr vdcrw
	ldx #19
	lda #0
	jsr vdcrw
	lda #31
	sta $d600		; set up for memory blast

	lda #0
	sta zp
	lda #32
	sta zp+1

	; strategy. copy 25 sections of 320x8 pixels, reorganizing it
	; to VDC linear memory

	lda #25
	sta $02			; count. when reaches zero, we're done

	; copy 320x8 segment
loop42	ldy #0
	; do 40 horizontal 8x1 cells to equal 320 horizontal pixels
loop41	ldx #0
loop40	lda (zp),y
	bit $d600
	bpl *-3
	sta $d601
	lda zp
	clc
	adc #8
	sta zp
	lda zp+1
	adc #0
	sta zp+1
	inx
	cpx #40
	bcc loop40
	; insert dummy byte between scanlines
	lda #0
	bit $d600
	bpl *-3
	sta $d601
	; do eight scan lines
	iny
	cpy #8
	bcs lupska
	; and take back one kadam to honor Bil Herd, whose Ark this is
	lda zp
	sec
	sbc #64
	sta zp
	lda zp+1
	sbc #1
	sta zp+1
	jmp loop41

	; and do it 25 times
lupska	dec $02
	bne loop42

	; colour cycle
	lda #26
	sta $d600
	lda #$f0
colup	bit $d600
	bpl *-3
	sta $d601
	ldx #0
	stx 162
	ldx 162
	cpx #60
	bne *-4
	clc
	adc #$10
	jmp colup

